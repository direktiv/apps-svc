description: |
  Service to regenerate the API responses.
  This should be called after changing data to apply the changes fully.
functions:
- id: pq
  type: subflow 
  workflow: "pq"
- id: generate-tags
  type: subflow 
  workflow: "generate-tags"
- id: load-specs
  type: subflow 
  workflow: "load-specs"
states:
- id: lookup-apps
  type: action
  action:
    function: pq
    input: 
      queries:
      # select get maxdate app from database. that is not the version but 
      # most likely it the latest will be the latest version
      - >- 
        SELECT a.uri, a.created_at, a.tag, encode(info, 'base64') as info from apps 
        AS a INNER JOIN (SELECT uri, max(created_at) AS maxdate FROM apps GROUP BY uri) tm 
        ON a.uri = tm.uri AND a.created_at = tm.maxdate
  transform: 'jq({data: .return.return.queries[0].result})'
  transition: prepare
- id: prepare
  type: noop
  transform: 
    # gets the info from db and uses fromjson to convert it. then rearrange it
    list: >-
      jq([ .data[] | .uri as $uri |  (.info | @base64d | fromjson ) as $meta |
        { $uri: { "tag": .tag, "uri": $uri, "created": .created_at, 
        "categories": $meta."x-direktiv-meta".categories, "description": 
        $meta.description, "title": $meta.title  }  } ])
  transition: setter
- id: setter
  type: setter
  variables:
  - scope: namespace
    key: "list_expanded"
    value: 'jq(.list)'
